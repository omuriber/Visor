<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <link rel="stylesheet" href="css/leaflet.css">
        <link rel="stylesheet" href="css/MarkerCluster.css">
        <link rel="stylesheet" href="css/MarkerCluster.Default.css">
        <link rel="stylesheet" href="css/L.Control.Locate.min.css">
        <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
        <link rel="stylesheet" href="css/qgis2web.css">
        <link rel="stylesheet" href="css/fontawesome-all.min.css">
        <style>
        html, body, #map {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        </style>
        <title>Mapa Grupos</title>
    </head>
    <body>
        <div id="map">
            <div id="controls">
                <button id="calculateRoutesBtn" class="map-btn" disabled>Calcular rutas</button>
            </div>
            <div id="loadingIndicator" class="loading-indicator">Calculando rutas...</div>
        </div>
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
        <script src="js/qgis2web_expressions.js"></script>
        <script src="js/L.Control.Layers.Tree.min.js"></script>
        <script src="js/L.Control.Locate.min.js"></script>
        <script src="js/leaflet.rotatedMarker.js"></script>
        <script src="js/leaflet.pattern.js"></script>
        <script src="js/leaflet-hash.js"></script>
        <script src="js/Autolinker.min.js"></script>
        <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
        <script src="js/rbush.min.js"></script>
        <script src="js/labelgun.min.js"></script>
        <script src="js/labels.js"></script>
        <script src="data/Puntos_1.js"></script>
        <script>
        var map = L.map('map', {
            zoomControl:false, maxZoom:28, minZoom:1
        })
        var hash = new L.Hash(map);
        map.attributionControl.setPrefix('<a href="https://github.com/tomchadwin/qgis2web" target="_blank">qgis2web</a> &middot; <a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a> &middot; <a href="https://qgis.org">QGIS</a>');
        var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});
        
        // remove popup's row if "visible-with-data"
        function removeEmptyRowsFromPopupContent(content, feature) {
         var tempDiv = document.createElement('div');
         tempDiv.innerHTML = content;
         var rows = tempDiv.querySelectorAll('tr');
         for (var i = 0; i < rows.length; i++) {
             var td = rows[i].querySelector('td.visible-with-data');
             var key = td ? td.id : '';
             if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                 rows[i].parentNode.removeChild(rows[i]);
             }
         }
         return tempDiv.innerHTML;
        }
        
        // add class to format popup if it contains media
        function addClassToPopupIfMedia(content, popup) {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            if (tempDiv.querySelector('td img')) {
                popup._contentNode.classList.add('media');
                    // Delay to force the redraw
                    setTimeout(function() {
                        popup.update();
                    }, 10);
            } else {
                popup._contentNode.classList.remove('media');
            }
        }
        
        var zoomControl = L.control.zoom({
            position: 'topleft'
        }).addTo(map);
        L.control.locate({locateOptions: {maxZoom: 19}}).addTo(map);
        var bounds_group = new L.featureGroup([]);
        function setBounds() {
            if (bounds_group.getLayers().length) {
                map.fitBounds(bounds_group.getBounds());
            }
        }
        map.createPane('pane_WazeWorld_0');
        map.getPane('pane_WazeWorld_0').style.zIndex = 400;
        var layer_WazeWorld_0 = L.tileLayer('https://worldtiles3.waze.com/tiles/{z}/{x}/{y}.png', {
            pane: 'pane_WazeWorld_0',
            opacity: 1.0,
            attribution: '',
            minZoom: 1,
            maxZoom: 28,
            minNativeZoom: 0,
            maxNativeZoom: 20
        });
        layer_WazeWorld_0;
        map.addLayer(layer_WazeWorld_0);
        
        function pop_Puntos_1(feature, layer) {
        var popupContent = '<table>\
        <tr>\
            <td class="visible-with-data" id="Nombre_com" colspan="2"><strong>Nombre</strong><br />' + (feature.properties['Nombre_com'] !== null ? autolinker.link(String(feature.properties['Nombre_com']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
        </tr>\
        <tr>\
            <td class="visible-with-data" id="N煤mero__1" colspan="2">\
                <div style="margin: 5px 0; display: flex; align-items: center;">\
                    <span style="margin-right: 10px;"><strong>N煤mero Telefonico:</strong> ' + (feature.properties['N煤mero__1'] !== null ? autolinker.link(String(feature.properties['N煤mero__1']).replace(/'/g, '\'').toLocaleString()) : '') + '</span>\
                    <button onclick="copyText(\'' + feature.properties['N煤mero__1'] + '\')" style="padding: 2px 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">Copiar</button>\
                </div>\
            </td>\
        </tr>\
        <tr>\
            <td class="visible-with-data" id="Modalidad" colspan="2"><strong>Modalidad</strong><br />' + (feature.properties['Modalidad'] !== null ? autolinker.link(String(feature.properties['Modalidad']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
        </tr>\
        <tr>\
            <td class="visible-with-data" id="Barrio_de" colspan="2"><strong>Barrio</strong><br />' + (feature.properties['Barrio_de'] !== null ? autolinker.link(String(feature.properties['Barrio_de']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
        </tr>\
        <tr>\
            <td class="visible-with-data" id="Direcci贸n" colspan="2">\
                <div style="margin: 5px 0; display: flex; align-items: center;">\
                    <span style="margin-right: 10px;"><strong>Direcci贸n:</strong> ' + (feature.properties['Direcci贸n'] !== null ? autolinker.link(String(feature.properties['Direcci贸n']).replace(/'/g, '\'').toLocaleString()) : '') + '</span>\
                    <button onclick="copyText(\'' + feature.properties['Direcci贸n'] + '\')" style="padding: 2px 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">Copiar</button>\
                </div>\
            </td>\
        </tr>\
        <tr>\
            <td class="visible-with-data" id="D铆a_en_qu" colspan="2"><strong>D铆a</strong><br />' + (feature.properties['D铆a_en_qu'] !== null ? autolinker.link(String(feature.properties['D铆a_en_qu']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
        </tr>\
        <tr>\
            <td class="visible-with-data" id="Hora_en_qu" colspan="2"><strong>Hora</strong><br />' + (feature.properties['Hora_en_qu'] !== null ? autolinker.link(String(feature.properties['Hora_en_qu']).replace(/'/g, '\'').toLocaleString()) : '') + '</td>\
        </tr>\
        </table>';
        var content = removeEmptyRowsFromPopupContent(popupContent, feature);
        layer.on('popupopen', function(e) {
        addClassToPopupIfMedia(content, e.popup);
        });
        layer.bindPopup(content, { maxHeight: 400 });
        }

        function style_Puntos_1_0() {
            return {
                pane: 'pane_Puntos_1',
                radius: 5.0,
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1,
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(152,125,183,1.0)',
                interactive: true,
                onClick: function(e) {
                    const feature = e.target.feature;
                    const contextMenu = document.createElement('div');
                    contextMenu.style.cssText = `
                        position: absolute;
                        background: white;
                        padding: 8px;
                        border-radius: 4px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                        z-index: 1000;
                    `;

                    const menuItems = [];
                    
                    if (feature.properties['Direcci贸n']) {
                        const direccionItem = document.createElement('div');
                        direccionItem.textContent = 'Copiar Direcci贸n';
                        direccionItem.style.cssText = 'padding: 4px 8px; cursor: pointer;';
                        direccionItem.onclick = () => {
                            copyText(feature.properties['Direcci贸n']);
                            contextMenu.remove();
                        };
                        menuItems.push(direccionItem);
                    }

                    if (feature.properties['N煤mero__1']) {
                        const numeroItem = document.createElement('div');
                        numeroItem.textContent = 'Copiar N煤mero';
                        numeroItem.style.cssText = 'padding: 4px 8px; cursor: pointer;';
                        numeroItem.onclick = () => {
                            copyText(feature.properties['N煤mero__1']);
                            contextMenu.remove();
                        };
                        menuItems.push(numeroItem);
                    }

                    menuItems.forEach(item => contextMenu.appendChild(item));
                    
                    const container = document.body;
                    const rect = e.target.getPopup().getElement().getBoundingClientRect();
                    const pos = {
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height + 10
                    };
                    
                    contextMenu.style.left = pos.x + 'px';
                    contextMenu.style.top = pos.y + 'px';
                    container.appendChild(contextMenu);
                    
                    // Eliminar el men煤 al hacer clic fuera
                    container.addEventListener('click', function handleClick(event) {
                        if (!contextMenu.contains(event.target)) {
                            contextMenu.remove();
                            container.removeEventListener('click', handleClick);
                        }
                    });
                }
            }
        }
        map.createPane('pane_Puntos_1');
        map.getPane('pane_Puntos_1').style.zIndex = 401;
        map.getPane('pane_Puntos_1').style['mix-blend-mode'] = 'normal';
        var layer_Puntos_1 = new L.geoJson(json_Puntos_1, {
            attribution: '',
            interactive: true,
            dataVar: 'json_Puntos_1',
            layerName: 'layer_Puntos_1',
            pane: 'pane_Puntos_1',
            onEachFeature: pop_Puntos_1,
            pointToLayer: function (feature, latlng) {
                return L.marker(latlng, {
                    icon: L.divIcon({
                        className: 'custom-point',
                        html: '<div class="point-dot"></div>'
                    })
                });
            },
        });
        bounds_group.addLayer(layer_Puntos_1);
        map.addLayer(layer_Puntos_1);
        setBounds();

        // Crear y a帽adir leyenda
        var legend = L.control({position: 'bottomright'});
        legend.onAdd = function(map) {
            var div = L.DomUtil.create('div', 'info legend');
            div.innerHTML = `
                <h4>Leyenda</h4>
                <div class="legend-item">
                    <div class="legend-icon" style="background-color: #987DB7;"></div>
                    <span class="legend-label">Grupos</span>
                </div>
            `;
            return div;
        };
        legend.addTo(map);

        // Configuraci贸n del geocodificador para Colombia
        var geocoder = L.Control.Geocoder.nominatim({
            geocodingQueryParams: {
                'countrycodes': 'co', // Limitar b煤squeda a Colombia
            }
        });

        // Crear el control de b煤squeda
        var searchControl = L.Control.geocoder({
            geocoder: geocoder,
            position: 'topleft',
            placeholder: 'Buscar ubicaci贸n...',
            defaultMarkGeocode: false,
            errorMessage: 'No se encontraron resultados',
            showResultIcons: true,
            suggestMinLength: 3,
            queryMinLength: 3,
            suggestTimeout: 250,
            collapsed: false
        }).addTo(map);

        // Agregar bot贸n de ubicaci贸n actual al control de b煤squeda
        var searchElement = searchControl.getContainer();
        var currentLocationButton = document.createElement('button');
        currentLocationButton.innerHTML = ' Ubicaci贸n actual';
        currentLocationButton.className = 'current-location-btn';
        currentLocationButton.onclick = function() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    var latlng = L.latLng(position.coords.latitude, position.coords.longitude);
                    
                    // Eliminar marcador anterior si existe
                    if (window.searchMarker) {
                        map.removeLayer(window.searchMarker);
                    }

                    // Crear nuevo marcador
                    window.searchMarker = L.marker(latlng, {
                        draggable: true
                    }).addTo(map);

                    // Configurar el popup del marcador
                    window.searchMarker.bindPopup('Tu ubicaci贸n actual').openPopup();

                    // Habilitar bot贸n de calcular rutas
                    document.getElementById('calculateRoutesBtn').disabled = false;

                    // Centrar el mapa en la ubicaci贸n
                    map.setView(latlng, 16);
                }, function(error) {
                    console.error('Error al obtener la ubicaci贸n:', error);
                    alert('No se pudo obtener tu ubicaci贸n. Por favor, verifica que hayas dado permiso para acceder a tu ubicaci贸n.');
                });
            } else {
                alert('Tu navegador no soporta geolocalizaci贸n.');
            }
        };
        searchElement.appendChild(currentLocationButton);

        // Manejar el resultado de la b煤squeda
        searchControl.on('markgeocode', function(e) {
            console.log('B煤squeda completada:', e);
            
            // Eliminar marcador anterior si existe
            if (window.searchMarker) {
                map.removeLayer(window.searchMarker);
            }
            
            // Crear nuevo marcador de b煤squeda
            window.searchMarker = L.marker(e.latlng || e.geocode.center, {
                icon: L.divIcon({
                    className: 'search-marker',
                    html: '<div class="point-dot"></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                }),
                draggable: true,
                autoPan: true
            }).addTo(map)
            .bindPopup('<b>Ubicaci贸n de b煤squeda:</b><br>' + e.geocode.name + 
                     '<br><small>Arrastra para ajustar la posici贸n</small>')
            .openPopup();
            
            // Actualizar el punto de inicio
            const newPos = window.searchMarker.getLatLng();
            startPoint = [newPos.lat, newPos.lng];
            
            // Habilitar bot贸n de calcular rutas
            document.getElementById('calculateRoutesBtn').disabled = false;
            
            // Actualizar el punto de inicio cuando se mueve el marcador
            window.searchMarker.on('dragend', function() {
                const newPos = window.searchMarker.getLatLng();
                startPoint = [newPos.lat, newPos.lng];
                window.searchMarker.setPopupContent(
                    '<b>Ubicaci贸n ajustada:</b><br>' + 
                    'Lat: ' + newPos.lat.toFixed(6) + ', Lng: ' + newPos.lng.toFixed(6) +
                    '<br><small>Arrastra para ajustar la posici贸n</small>'
                );
                
                // Si ya hay rutas calculadas, actualizarlas
                if (window.currentRoutes && window.currentRoutes.length > 0) {
                    calculateRoutesFromPoint(startPoint);
                }
            });
            
            // Centrar el mapa en la ubicaci贸n encontrada
            map.setView(e.latlng || e.geocode.center, 16);
            
            console.log('Marcador de b煤squeda colocado en:', startPoint);
        });

        // Funci贸n para calcular rutas desde un punto espec铆fico
        async function calculateRoutesFromPoint(startPoint) {
            if (!startPoint) return;
            
            const loadingIndicator = document.getElementById('loadingIndicator');
            const routesLayer = window.routesLayer || L.layerGroup().addTo(map);
            window.routesLayer = routesLayer;
            routesLayer.clearLayers();
            
            loadingIndicator.style.display = 'block';
            
            try {
                // Convertir a array [lat, lng] si es un objeto LatLng
                const startCoords = Array.isArray(startPoint) ? 
                    startPoint : 
                    [startPoint.lat, startPoint.lng];
                
                // Obtener los 3 puntos m谩s cercanos
                const closestPoints = getClosestPoints(3, startCoords);
                
                // Calcular ruta a cada punto
                for (let i = 0; i < closestPoints.length; i++) {
                    const point = closestPoints[i];
                    const route = await getRouteFromOSRM(
                        startCoords,
                        [point.geometry.coordinates[1], point.geometry.coordinates[0]]
                    );
                    
                    if (route) {
                        createRouteLayer(route, i, point);
                    }
                }
                
                // Guardar rutas actuales para poder actualizarlas
                window.currentRoutes = closestPoints;
                
            } catch (error) {
                console.error('Error al calcular rutas:', error);
                alert('Error al calcular las rutas. Por favor, int茅ntalo de nuevo.');
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Variables globales
        var startMarker = null;  // Marcador de b煤squeda
        var startPoint = null;   // Coordenadas del punto de inicio seleccionado
        let routesLayer = L.layerGroup().addTo(map);
        let routeMarkers = L.layerGroup().addTo(map);

        // Configuraci贸n de colores y API
        const routeColors = ['#FF6B6B', '#4ECDC4', '#45B7D1']; // Rojo, Turquesa, Azul
        const routeNames = ['Primera', 'Segunda', 'Tercera'];
        const OSRM_BASE_URL = 'https://router.project-osrm.org/route/v1/driving';

        // Funci贸n para mostrar/ocultar indicador de carga
        function showLoading(show) {
            document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
        }

        // Funci贸n para calcular distancia Haversine (l铆nea recta)
        function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radio de la Tierra en km
            const 1 = lat1 * Math.PI/180;
            const 2 = lat2 * Math.PI/180;
            const  = (lat2-lat1) * Math.PI/180;
            const 位 = (lon2-lon1) * Math.PI/180;

            const a = Math.sin(/2) * Math.sin(/2) +
                Math.cos(1) * Math.cos(2) *
                Math.sin(位/2) * Math.sin(位/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // Distancia en kil贸metros
        }

        // Funci贸n para obtener puntos m谩s cercanos por distancia en l铆nea recta
        function getClosestPoints(limit = 3, startPoint = null) {
            if (!startPoint) return [];
            const start = startPoint;
            
            return layer_Puntos_1.getLayers()
                .map(layer => ({
                    layer,
                    destino: layer.getLatLng(),
                    geometry: {
                        type: 'Point',
                        coordinates: [layer.getLatLng().lng, layer.getLatLng().lat]
                    },
                    properties: layer.feature.properties,
                    distance: calculateHaversineDistance(
                        start[0], start[1],
                        layer.getLatLng().lat, layer.getLatLng().lng
                    )
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, limit);
        }

        // Funci贸n para obtener ruta usando OSRM
        async function getRouteFromOSRM(start, end) {
            const url = `${OSRM_BASE_URL}/${start[1]},${start[0]};${end.lng},${end.lat}?overview=full&geometries=geojson&steps=false`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    return {
                        geometry: data.routes[0].geometry,
                        distance: data.routes[0].distance / 1000, // Convertir a km
                        duration: data.routes[0].duration / 60, // Convertir a minutos
                        destination: end
                    };
                } else {
                    throw new Error('No se encontr贸 ruta');
                }
            } catch (error) {
                console.error('Error al obtener ruta de OSRM:', error);
                throw error;
            }
        }

        // Funci贸n para crear y mostrar la capa de ruta
        function createRouteLayer(routeData, index, pointData) {
            const color = routeColors[index];
            const routeName = routeNames[index];
            
            // Crear l铆nea de ruta
            const routeLayer = L.geoJSON(routeData.geometry, {
                style: {
                    color: color,
                    weight: 5,
                    opacity: 0.8,
                    dashArray: index === 0 ? '' : '10, 5' // Primera ruta s贸lida, otras punteadas
                }
            }).addTo(routesLayer);
            
            // Popup para la l铆nea de ruta
            const routePopupContent = `
                <div style="font-family: Arial, sans-serif; min-width: 200px;">
                    <h4 style="margin: 0 0 10px 0; color: ${color};">${routeName} ruta m谩s corta</h4>
                    <p style="margin: 5px 0;"><strong>Distancia:</strong> ${routeData.distance.toFixed(2)} km</p>
                    <p style="margin: 5px 0;"><strong>Destino:</strong> ${pointData.properties['Nombre_com'] || 'Sin nombre'}</p>
                </div>
            `;
            routeLayer.bindPopup(routePopupContent);
            
            // Marcador numerado en el destino
            const destinationMarker = L.marker(routeData.destination, {
                icon: L.divIcon({
                    className: 'route-marker',
                    html: `<div style="
                        background: ${color}; 
                        color: white; 
                        border-radius: 50%; 
                        width: 30px; 
                        height: 30px; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center;
                        font-weight: bold;
                        font-size: 16px;
                        border: 3px solid white;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                    ">${index + 1}</div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            }).addTo(routeMarkers);
            
            // Popup para el marcador de destino
            const destinationPopupContent = `
                <div style="font-family: Arial, sans-serif; min-width: 200px;">
                    <h4 style="margin: 0 0 10px 0; color: ${color};">Destino ${index + 1}</h4>
                    <p style="margin: 5px 0;"><strong>Nombre:</strong> ${pointData.properties['Nombre_com'] || 'Sin nombre'}</p>
                    <div style="margin: 5px 0; display: flex; align-items: center;">
                        <span style="margin-right: 10px;"><strong>Numero:</strong> ${pointData.properties['N煤mero__1'] || 'Sin nombre'}</span>
                        <button onclick="copyText('${pointData.properties['N煤mero__1'] || 'Sin nombre'}')" 
                                style="padding: 2px 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">
                            Copiar
                        </button>
                    </div>
                    <div style="margin: 5px 0; display: flex; align-items: center;">
                        <span style="margin-right: 10px;"><strong>Direcci贸n:</strong> ${pointData.properties['Direcci贸n'] || 'No disponible'}</span>
                        <button onclick="copyText('${pointData.properties['Direcci贸n'] || 'No disponible'}')" 
                                style="padding: 2px 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">
                            Copiar
                        </button>
                    </div>
                    <p style="margin: 5px 0;"><strong>Barrio:</strong> ${pointData.properties['Barrio_de'] || 'No disponible'}</p>
                    <p style="margin: 5px 0;"><strong>Distancia:</strong> ${routeData.distance.toFixed(2)} km</p>
                </div>
            `;
            destinationMarker.bindPopup(destinationPopupContent);
        }

        // Configurar el marcador de b煤squeda
        function setupSearchMarker(e) {
            // Eliminar marcador anterior si existe
            if (window.searchMarker) {
                map.removeLayer(window.searchMarker);
            }
            
            // Crear nuevo marcador de b煤squeda
            window.searchMarker = L.marker(e.latlng, {
                icon: L.divIcon({
                    className: 'search-marker',
                    html: '<div class="point-dot"></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                }),
                draggable: true
            }).addTo(map)
            .bindPopup('Punto de partida')
            .openPopup();
            
            // Actualizar coordenadas cuando se arrastra el marcador
            window.searchMarker.on('dragend', function() {
                const newPos = window.searchMarker.getLatLng();
                startPoint = [newPos.lat, newPos.lng];
                
                // Si hay rutas calculadas, actualizarlas
                if (window.currentRoutes && window.currentRoutes.length > 0) {
                    calculateRoutesFromPoint(startPoint);
                }
            });
            
            // Guardar el punto de inicio
            startPoint = [e.latlng.lat, e.latlng.lng];
            
            // Habilitar bot贸n de calcular rutas
            document.getElementById('calculateRoutesBtn').disabled = false;
            
            console.log('Punto de partida establecido:', startPoint);
            
            // Si hay rutas calculadas, actualizarlas
            if (window.currentRoutes && window.currentRoutes.length > 0) {
                calculateRoutesFromPoint(startPoint);
            }
        }

        // Calcular rutas a los 3 puntos m谩s cercanos
        document.getElementById('calculateRoutesBtn').addEventListener('click', async function() {
            // Verificar que exista un punto de b煤squeda
            if (!window.searchMarker) {
                alert('Por favor, busca una direcci贸n primero para establecer el punto de partida');
                return;
            }
            
            const startPoint = window.searchMarker.getLatLng();
            
            const btn = this;
            btn.textContent = 'Calculando rutas...';
            btn.disabled = true;
            showLoading(true);
            
            try {
                // Limpiar rutas y marcadores anteriores
                routesLayer.clearLayers();
                routeMarkers.clearLayers();
                
                const startCoords = [startPoint.lat, startPoint.lng];
                console.log('Iniciando c谩lculo de rutas desde:', startCoords);
                
                // Obtener 3 puntos m谩s cercanos al punto de inicio
                const closestPoints = getClosestPoints(3, startCoords);
                
                if (closestPoints.length === 0) {
                    throw new Error('No se encontraron puntos de destino');
                }
                
                console.log('Puntos m谩s cercanos encontrados:', closestPoints);
                
                // Calcular ruta a cada punto
                const routePromises = closestPoints.map(point => 
                    getRouteFromOSRM(startCoords, point.destino)
                );
                
                // Esperar a que todas las rutas se calculen
                const routeResults = await Promise.all(routePromises);
                
                // Filtrar rutas v谩lidas y ordenar por distancia real (no l铆nea recta)
                const validRoutes = routeResults
                    .map((route, index) => ({
                        ...route,
                        pointData: closestPoints[index]
                    }))
                    .filter(route => route !== null)
                    .sort((a, b) => a.distance - b.distance);
                
                if (validRoutes.length === 0) {
                    throw new Error('No se pudieron calcular rutas v谩lidas');
                }
                
                console.log(`Se calcularon ${validRoutes.length} rutas v谩lidas`);
                
                // Mostrar las rutas (m谩ximo 3)
                const routesToShow = validRoutes.slice(0, 3);
                
                routesToShow.forEach((routeData, index) => {
                    createRouteLayer(routeData, index, routeData.pointData);
                    console.log(`Ruta ${index + 1}: ${routeData.distance.toFixed(2)} km, ${Math.round(routeData.duration)} min`);
                });
                
                // Ajustar la vista del mapa para mostrar todas las rutas
                const allPoints = routesToShow.map(route => L.latLng(route.destination.lat, route.destination.lng));
                if (allPoints.length > 0) {
                    allPoints.push(window.searchMarker.getLatLng());
                    const group = new L.featureGroup(allPoints.map(latlng => L.marker(latlng)));
                    map.fitBounds(group.getBounds().pad(0.1));
                }
                
                btn.textContent = 'Rutas calculadas';
                console.log('Rutas calculadas y mostradas exitosamente');
                
            } catch (error) {
                console.error('Error al calcular rutas:', error);
                alert('Error al calcular las rutas: ' + error.message + '. Por favor, intenta nuevamente.');
                btn.textContent = 'Error - Reintentar';
            } finally {
                showLoading(false);
                btn.disabled = false;
            }
        });
        </script>
    <script>
        function copyText(text) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    alert('Direcci贸n copiada al portapapeles!');
                })
                .catch(err => {
                    console.error('Error al copiar:', err);
                    alert('No se pudo copiar la direcci贸n. Por favor, intenta copiar manualmente.');
                });
        }
    </script>
    </body>
</html>